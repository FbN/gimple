{"name":"Gimple","tagline":"Micro, performant, and thread safe dependency injection container for jvm. Inspired by PHP Pimple. Written in Groovy. Powered by Google Guava Stripe.","body":"# Gimple\r\nGimple is a small Dependency Injection Container for Groovy, Java and more generally for JVM. Consists of just one class ( ... maybe two ). Is inspired (and in many points carbon-copied) to the [PHP Pimple project]( http://pimple.sensiolabs.org/ )\r\n\r\nHomepage: http://fbn.github.io/gimple/\r\n\r\n## Features\r\n\r\n* **Simple**: one (... maybe two) class.\r\n* **Modern**: strong use of closure\r\n* **Thread safty & efficency**: powered by [Guava Stripe](https://code.google.com/p/guava-libraries/wiki/StripedExplained). Tested with [thread-safe.org](http://thread-safe.org/).\r\n* **Nice API**: the container is an LinkedHashMap extension. In groovy you can use it like a Map, [:].\r\n* **Prototype / Singleton**: define singleton o prototype scoped services or parameters.\r\n\r\n## Why!?\r\n\r\nJava, and more generally JVM, already got many dependency injection containers ( spring framework, google guice, picocontainer )\r\nbut all of them are heavy libraries composed of dozens of classes. \r\n\r\nThis is a one class!\r\n\r\n## Usage\r\n\r\nGimple is published via Maven:\r\n* Maven repository: https://github.com/FbN/mvn/raw/master/\r\n* Maven artifact: com.github.gimple Gimple 0.1.2\r\n\r\nIf you use gradle simply:\r\n\r\n```groovy\r\nrepositories {\r\n    maven {\r\n        url 'https://github.com/FbN/mvn/raw/master/'\r\n    }\r\n} \r\ndependencies {\r\n    compile 'com.github.gimple:Gimple:0.1.2'\r\n}\r\n```\r\n\r\n## API\r\n\r\n### Instantiate\r\n```groovy\r\ndef container = new gimple.Container()\r\n```\r\n\r\n### Defining Services\r\nA service is an object that does something as part of a larger system. \r\nExamples of services: a database connection, a templating engine, or a mailer. \r\nAlmost any global object can be a service.\r\nServices are defined by closure that return an instance of an object:\r\n\r\n```groovy\r\ncontainer['sessionStorage'] = { c->\r\n    new SessionStorage('SESSION_ID')\r\n}\r\n\r\ncontainer['session'] = { c->\r\n    new Session(c['sessionStorage'])\r\n}\r\n```\r\nNotice that closure has access to the current container instance, allowing references to other services or parameters.\r\n\r\nAs objects are only created when you get them, the order of the definitions does not matter.\r\n\r\nUsing the defined services is also very easy:\r\n\r\n```groovy\r\ndef session = container['session']\r\n```\r\n\r\n### Defining Factory Services\r\n\r\nBy default, each time you get a service, Gimple returns the same instance of it. \r\nIf you want a different instance to be returned for all calls, wrap your closure with the factory() method\r\n\r\n```groovy\r\ncontainer['session'] = container.factory( { c->\r\n    new Session(c['sessionStorage'])\r\n    })\r\n```\r\nNow, each call to container['session'] returns a new instance of the session.\r\n\r\n### Defining Parameters\r\n\r\nDefining a parameter allows to ease the configuration of your container from the outside and to store global values:\r\n```groovy\r\ncontainer['cookieName'] = 'SESSION_ID'\r\ncontainer['sessionStorageClass'] = 'SessionStorage'\r\n```\r\nIf not is a closure is a parameter.\r\n\r\nIf you change the sessionStorage service definition like below:\r\n\r\n```groovy\r\ncontainer['sessionStorage'] = { c->\r\n    new \"${c['sessionStorageClass']}\"(c['cookieName'])\r\n}\r\n```\r\n\r\n### Protecting Parameters\r\nBecause Gimple sees clsure as service definitions, you need to wrap closure with the protect() method to store them as parameters:\r\n\r\n```groovy\r\ncontainer['randomFunc'] = container.protect({ new Random().nextInt() })\r\n```\r\n\r\n### Modifying Services after Definition\r\nYou can replace a service simple reassigning a new value to id (the service must not be already used).\r\nIn some cases you may want to modify a service definition after it has been defined without replacing it. You can see it as a filter applied after the original service.\r\nYou can use the extend() method to define additional code to be run on your service just after it is created:\r\n\r\n```groovy\r\ncontainer['sessionStorage'] = { c->\r\n    new \"${c['sessionStorageClass']}\"(c['cookieName'])\r\n};\r\n\r\ncontainer->extend('sessionStorage', {storage, c->\r\n    ...\r\n    do anything with storage and c\r\n    ...\r\n\r\n    storage\r\n})\r\n```\r\nThe first argument is the name of the service to extend, the second a function that gets access to the object instance and the container.\r\n\r\n### Extending a Container\r\n\r\nIf you use the same libraries over and over, you might want to reuse some services from one project to the next one; package your services into a provider by implementing gimple.ServiceProviderInterface:\r\n\r\n```groovy\r\nclass FooProvider implements gimple.ServiceProviderInterface\r\n{\r\n    def register(Container gimple)\r\n    {\r\n        // register some services and parameters\r\n        // on gimple\r\n    }\r\n}\r\n```\r\n\r\nThen, register the provider on a Container:\r\n\r\n```groovy\r\ngimple.register(new FooProvider())\r\n```\r\n\r\n### Fetching the Service Creation Function\r\nWhen you access an object, Gimple automatically calls the closure that you defined, which creates the service object for you. If you want to get raw access to the closure, you can use the raw() method:\r\n\r\n```groovy\r\ncontainer['session'] = { c->\r\n    new Session(c['sessionStorage'])\r\n};\r\n\r\ndef sessionFunction = container.raw('session')\r\n```\r\n\r\n## Authors and Contributors\r\n@fbn Fabiano Taioli  ftaioli@gmail.com\r\n\r\n","google":"UA-20498374-1","note":"Don't delete this file! It's used internally to help with page regeneration."}